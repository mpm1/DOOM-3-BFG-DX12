#include "global.inc"
#include "hiz_depth.inc"

uniform Texture2D<float4> samp0 : register(t0); // Rendered Image (previous frame)
uniform Texture2D<float4> samp1 : register(t1); // Normal Map
uniform Texture2D<float4> samp2 : register(t2); // Material
uniform Texture2D<float4> samp3 : register(t3); // World Coordinates
uniform Texture2D<float4> samp4 : register(t4); // Specular properties

struct PS_IN {
	float4 position : SV_POSITION;
	float2 texcoord0 : TEXCOORD0_centroid;
};

struct PS_OUT {
	float4 vector : SV_TARGET0;
	float4 color : SV_TARGET1;
};

float3 GetUVCoordinates(in float4 worldCoord)
{
	float4 fragCoord;

	fragCoord.x = dot4( worldCoord, sceneConstants.rpMVPmatrixX );
	fragCoord.y = dot4( worldCoord, sceneConstants.rpMVPmatrixY );
	fragCoord.z = dot4( worldCoord, sceneConstants.rpMVPmatrixZ );
	fragCoord.w = dot4( worldCoord, sceneConstants.rpMVPmatrixW );

	fragCoord.xyz /= fragCoord.w;
	fragCoord.xy = (fragCoord.xy * 0.5) + 0.5;

	return fragCoord.xyz;
}

float3 GetFragCoordinates(in float4 worldCoord)
{
	float4 fragCoord;

	fragCoord.x = dot4( worldCoord, sceneConstants.rpMVPmatrixX );
	fragCoord.y = dot4( worldCoord, sceneConstants.rpMVPmatrixY );
	fragCoord.z = dot4( worldCoord, sceneConstants.rpMVPmatrixZ );
	fragCoord.w = dot4( worldCoord, sceneConstants.rpMVPmatrixW );

	fragCoord.xyz /= fragCoord.w;
	fragCoord.xy = fragCoord.xy * 0.5 + 0.5;

	fragCoord.xy /= sceneConstants.rpWindowCoord.xy;

	return fragCoord.xyz; // TODO: Pass in the depth buffer values and make this float2
}

void main( PS_IN fragment, out PS_OUT result ) {
	// TODO: move these properties into a constant buffer
	float maxDistance = 1.0;
	float resolution = 0.3;
	int steps = 5;
	float thickness = 0.001;
	float roughnessCutoff = 0.8; // Anything higher will not do screen space reflections
	float angularCutoff = 0.01; // Cutoff in which the angle is too pointed at the camera.

	float2 tCoords = fragment.texcoord0;

	float3 worldPosition = samp3.Sample(pointSampler, tCoords).xyz;
	float3 normal = normalize((samp1.Sample(pointSampler, tCoords).xyz * 2.0) - 1.0);
	
	float3 eyeToPoint = normalize(worldPosition - sceneConstants.rpGlobalEyePos.xyz);
	float3 reflectionVector = normalize(reflect(eyeToPoint, normal));

	float viewAmount = abs(dot3(eyeToPoint, reflectionVector));
	result.vector = float4(reflectionVector * 0.5 + 0.5, 1.0);
	result.color = float4(0.0, 0.0, 0.0, 0.0);

	if(viewAmount > angularCutoff)
	{
		float roughness, baseReflection, metalness;

		{
			float3 specular = samp4.Sample(pointSampler, tCoords).rgb;
			float3 materialProperties = samp2.Sample(pointSampler, tCoords).rgb;

			ExtractMaterialProperties(
				specular, materialProperties,
				roughness, baseReflection, metalness);
		}

		if(roughness < roughnessCutoff)
		{
			float3 startUV = GetUVCoordinates(float4(worldPosition, 1.0));

			float4 endPosition = float4(worldPosition + (reflectionVector * maxDistance), 1.0);
			float3 uvVector = normalize(GetUVCoordinates(endPosition) - startUV);

			float4 screenSpaceIntersection = FindIntersectingDepthPoint(startUV, uvVector, resolution, steps, thickness); //ScreenSpaceTraceRay(startFrag, endFrag, resolution, steps, thickness);

			result.color.rgb = samp0.Sample(baseSampler, screenSpaceIntersection.xy).rgb;
			result.color.w = screenSpaceIntersection.w; 

			//result.color = float4(uvVector.xy * 0.5 + 0.5, 0.0, screenSpaceIntersection.w);
		}
	}
}
