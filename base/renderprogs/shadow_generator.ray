#include "raytracing_global.inc"

// Raytracing output to texture, accessed as UAV
RWTexture2D<uint4> shadowMask :register(u0);
RWTexture2D<float4> diffuseMask :register(u1);

// Raytracing acceleration structure, accessed as a SRV
RaytracingAccelerationStructure SceneBVH :register(t0);

// Depth buffer used to access the initial location
uniform Texture2D<float>	depthBuffer : register(t1);
//uniform Texture2D<float>	normalMap	: register(t2);

// Constants used to define the camera state
ConstantBuffer<SceneConstants> sceneConstants : register(b0, space0);

bool IsInsideViewport(float2 p, float4 viewport)
{
	return (p.x >= viewport.x && p.x <= viewport.z)
		&& (p.y >= viewport.y && p.y <= viewport.w);

	return true;
}

[shader("raygeneration")]
void RayGen() {
	uint resultMask = 0x00000000;
	float3 resultDiffuse = float3(0.0, 0.0, 0.0);

	// Get the ray location on the screen
	float2 lerpValues = ((float2)DispatchRaysIndex() + 0.5) / (float2)DispatchRaysDimensions();
	float3 screenLocation = float3(
		lerp(sceneConstants.rp.viewport.x, sceneConstants.rp.viewport.z, lerpValues.x),
		lerp(sceneConstants.rp.viewport.y, sceneConstants.rp.viewport.w, lerpValues.y),
		0.0f);
	
	uint lightCounts = min(sceneConstants.lightCount, MAX_SHADOW_LIGHTS);

	// Get the depth buffer location
	float depth = depthBuffer.GatherRed(pointSampler, lerpValues.xy).r;

	{		
		float3 worldPosition = GetWorldPointFromDepth(depth, lerpValues, sceneConstants).xyz;
		float3 pointToEye = normalize(sceneConstants.rp.globalEyePos.xyz - worldPosition);

		float minDist = 3.0; // TODO: Move this out based on normal.
		float3 startingPoint = worldPosition + (pointToEye * minDist); // Start slightly out from the world position.

		for(uint lightIndex = 0; lightIndex < sceneConstants.lightCount; ++lightIndex)
		{
			SceneLight light = sceneConstants.lights[lightIndex];
			uint shadowMask = light.shadowMask;

			//float3 randValue = normalize(random3(lerpValues.xy + light.pad1) * 2.0 - 1.0); //TODO: Add a time value

			//TODO: fix the scissor window. //if (IsInsideViewport(screenLocation.xy, light.scissor))
			{
				float3 localDiffuse = float3(0.0, 0.0, 0.0); // We can average this value if we want to cast multiple rays for this light.
				float3 lightPosition = light.location; // + (light.emmisiveRadius.xyz * randValue);
				float radius = light.radius + minDist;

				// Initialize the ray payload
				ShadowHitInfo payload;
				payload.maxDistance = distance(lightPosition, startingPoint);
				payload.intensity = 0.0;

				float intensity = 1.0 - max(0.0, payload.maxDistance / radius);

				if(intensity > 0)
				{
					// We are inside the light radius.
					// Define a ray, consisting of origin, direction, and the min-max distance values
					RayDesc ray;
					ray.TMin = 0.001;
					ray.TMax = payload.maxDistance;
					ray.Origin = lightPosition;
					ray.Direction = normalize(startingPoint - lightPosition);

					TraceRay(
						SceneBVH,
						RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH, //RAY_FLAG_CULL_BACK_FACING_TRIANGLES,
						0xFF,
						0,
						0, // First Hit Shader
						0, // Miss Shader
						ray,
						payload
					);

					if (payload.intensity > 0.0)
					{
						resultMask += shadowMask;

						localDiffuse += (light.color * pow(intensity, 2.0));// Squared falloff
					}
				}

				resultDiffuse += localDiffuse;
			}
		}
	}
	
	shadowMask[DispatchRaysIndex().xy] = ConvertShadowmapMaskToVector(resultMask);
	diffuseMask[DispatchRaysIndex().xy] = float4(resultDiffuse.rgb, 1.0);
}