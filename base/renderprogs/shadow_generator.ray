#include "raytracing_global.inc"

// Raytracing output to texture, accessed as UAV
RWTexture2D<uint4> shadowMask :register(u0);
RWTexture2D<float4> diffuseMask :register(u1);

// Raytracing acceleration structure, accessed as a SRV
RaytracingAccelerationStructure SceneBVH :register(t0);

// Depth buffer used to access the initial location
uniform Texture2D<float>	depthBuffer : register(t1);
uniform Texture2D<float4>	normalMap	: register(t2);

// Constants used to define the camera state
ConstantBuffer<SceneConstants> sceneConstants : register(b0, space0);

bool IsInsideViewport(float2 p, float4 viewport)
{
	return (p.x >= viewport.x && p.x <= viewport.z)
		&& (p.y >= viewport.y && p.y <= viewport.w);

	return true;
}

[shader("raygeneration")]
void RayGen() {
	uint resultMask = 0x00000000;
	float3 resultDiffuse = float3(0.0, 0.0, 0.0);

	// Get the ray location on the screen
	float2 lerpValues = ((float2)DispatchRaysIndex() + 0.5) / (float2)DispatchRaysDimensions();
	float3 screenLocation = float3(
		lerp(sceneConstants.rp.viewport.x, sceneConstants.rp.viewport.z, lerpValues.x),
		lerp(sceneConstants.rp.viewport.y, sceneConstants.rp.viewport.w, lerpValues.y),
		0.0f);
	
	uint lightCounts = min(sceneConstants.lightCount, MAX_SHADOW_LIGHTS);

	// Get the depth buffer location
	float depth = depthBuffer.GatherRed(pointSampler, lerpValues.xy).r;
	float3 normal = normalize((normalMap.Gather(pointSampler, lerpValues.xy).xyz * 2.0) - 1.0);

	{		
		float3 worldPosition = GetWorldPointFromDepth(depth, lerpValues, sceneConstants).xyz; //Mark start here. is this truely correct?
		float3 pointToEye = normalize(sceneConstants.rp.globalEyePos.xyz - worldPosition);

		for(uint lightIndex = 0; lightIndex < sceneConstants.lightCount; ++lightIndex)
		{
			SceneLight light = sceneConstants.lights[lightIndex];
			uint shadowMask = light.shadowMask;

			//float3 randValue = normalize(random3(lerpValues.xy + light.pad1) * 2.0 - 1.0); //TODO: Add a time value

			//TODO: fix the scissor window. //if (IsInsideViewport(screenLocation.xy, light.scissor))
			{
				float3 localDiffuse = float3(0.0, 0.0, 0.0); // We can average this value if we want to cast multiple rays for this light.
				float3 lightPosition = light.center; // + (light.emmisiveRadius.xyz * randValue);
				float radius = light.radius;

				float3 lightVector = normalize(lightPosition - worldPosition); //Or is this the wrong angle?

				float intensity = saturate(dot(normal, lightVector));

				// Initialize the ray payload
				ShadowHitInfo payload;
				payload.maxDistance = min(radius, distance(lightPosition, worldPosition));
				payload.intensity = 0.0;
				
				if(intensity > 0.0) //TODO: Do this only for point lights and find the true radius distance based on the 3d radius vector and center offset.
				{
					float falloff = pow(1.0 - max(0.0, payload.maxDistance / radius), 2.0); // Squared falloff 
					intensity *= falloff;
				}
				
				payload.intensity = intensity;

				if(intensity > 0)
				{
					if(light.flags & LIGHT_FLAG_CASTS_SHADOWS == LIGHT_FLAG_CASTS_SHADOWS) // For now, all lights will cast shadows.
					{
						// We are inside the light radius.
						// Define a ray, consisting of origin, direction, and the min-max distance values
						RayDesc ray;
						ray.TMin = 1.0;
						ray.TMax = payload.maxDistance;
						ray.Origin = worldPosition;
						ray.Direction = lightVector;

						TraceRay(
							SceneBVH,
							RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH, //RAY_FLAG_CULL_BACK_FACING_TRIANGLES,
							0xFF,
							0,
							0, // First Hit Shader
							0, // Miss Shader
							ray,
							payload
						);
					}

					if (payload.intensity > 0.0)
					{
						resultMask += shadowMask;

						localDiffuse += (light.color.rgb * intensity); // TODO: Get real light and color from the light texture.
					}
				}

				resultDiffuse += saturate(localDiffuse); // TODO: Change this to a colour light space
			} 
		}
	}
	
	shadowMask[DispatchRaysIndex().xy] = ConvertShadowmapMaskToVector(resultMask);
	diffuseMask[DispatchRaysIndex().xy] = float4(saturate(resultDiffuse.rgb), 1.0);
}