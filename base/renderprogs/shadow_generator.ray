#include "raytracing_global.inc"

// Raytracing output to texture, accessed as UAV
RWTexture2D<uint4> shadowMask :register(u0);
RWTexture2D<float4> diffuseMask :register(u1);

// Raytracing acceleration structure, accessed as a SRV
RaytracingAccelerationStructure SceneBVH :register(t0);

// Constants used to define the camera state
ConstantBuffer<RaytracedSceneConstants> sceneConstants : register(b0, space0);

bool IsInsideViewport(float2 p, float4 viewport)
{
	return (p.x >= viewport.x && p.x <= viewport.z)
		&& (p.y >= viewport.y && p.y <= viewport.w);
}

float3 CalculateFalloff(in SceneLight light, float4 worldPosition)
{
	Texture2D<float4> falloffTexture =  GetBindlessTexture4f(light.falloffIndex);
	float4 falloff = falloffTexture.SampleLevel(projectionSampler, float2(dot4( worldPosition, light.falloffS ), 0), 0);
	
	return falloff.rgb;
}

float3 CalculateProjection(in SceneLight light, float4 worldPosition)
{
	float4 projection = float4(
		dot4(worldPosition, light.projectionS),
		dot4(worldPosition, light.projectionT),
		0.0f,
		dot4(worldPosition, light.projectionQ)
	);

	projection.xy /= projection.w;
	Texture2D<float4> projectionTexture = GetBindlessTexture4f(light.projectionIndex);

	return projectionTexture.SampleLevel(projectionSampler, projection.xy, 0).rgb;
}

[shader("raygeneration")]
void RayGen() {
	uint resultMask = 0x00000000;
	float3 resultDiffuse = float3(0.0, 0.0, 0.0);

	// Get the ray location on the screen
	float2 lerpValues = ((float2)DispatchRaysIndex() + 0.5) / (float2)DispatchRaysDimensions();
	float3 screenLocation = float3(
		lerp(sceneConstants.rp.viewport.x, sceneConstants.rp.viewport.z, lerpValues.x),
		lerp(sceneConstants.rp.viewport.y, sceneConstants.rp.viewport.w, 1.0 - lerpValues.y), // We need to flip the y coordinates due to the directx screen coordinates.
		0.0f);
	
	uint lightCounts = min(sceneConstants.lightCount, MAX_SHADOW_LIGHTS);

	// Get the depth buffer location
	float depth = GetBindlessTexture1f(sceneConstants.depthTextureIndex).GatherRed(pointSampler, lerpValues.xy).r;

	if(depth != 0) // A depth of absolute 0 is considered invalid.
	{

		// Calculate the offset from the ray start we'd like to use.
		// This is done to help with precision errors the further away our surface is.
		float rayStartDistance = lerp(0.0, 20.0, depth / 1000.0f);
	

		float3 flatNormal = normalize((GetBindlessTexture4f(sceneConstants.flatNormalIndex).SampleLevel(pointSampler, lerpValues.xy, 0).xyz * 2.0) - 1.0);
		float3 normal = normalize((GetBindlessTexture4f(sceneConstants.normalIndex).SampleLevel(pointSampler, lerpValues.xy, 0).xyz * 2.0) - 1.0);

		{		
			float3 worldPosition = GetWorldPointFromDepth(depth, lerpValues, sceneConstants).xyz + (k_minSurfaceDistance * flatNormal);
			float3 pointToEye = normalize(sceneConstants.rp.globalEyePos.xyz - worldPosition);

			for(uint lightIndex = 0; lightIndex < sceneConstants.lightCount; ++lightIndex)
			{
				SceneLight light = sceneConstants.lights[lightIndex];
				uint shadowMask = light.shadowMask;

				//float3 randValue = normalize(random3(lerpValues.xy + light.pad1) * 2.0 - 1.0); //TODO: Add a time value

				if (IsInsideViewport(screenLocation.xy, light.scissor))
				{
					float3 localDiffuse = float3(0.0, 0.0, 0.0); // We can average this value if we want to cast multiple rays for this light.
					float3 lightPosition = light.center; // + (light.emmisiveRadius.xyz * randValue);
					float maxDistance = distance(lightPosition, worldPosition);

					float3 lightVector = normalize(lightPosition - worldPosition);

					float intensity = saturate(dot(normal, lightVector));
					float3 lightColor = float3(intensity, intensity, intensity);

					if(intensity > 0.0) //TODO: Do this only for point lights and find the true radius distance based on the 3d radius vector and center offset.
					{
						lightColor = lightColor * 
							CalculateFalloff(light, float4(worldPosition, 1.0)) * 
							CalculateProjection(light, float4(worldPosition, 1.0));
					}

					if(intensity > 0 && length(lightColor) > 0)
					{
						// Initialize the ray payload
						ShadowHitInfo payload;
						payload.maxDistance = maxDistance;
						payload.intensity = intensity;

						if(light.flags & LIGHT_FLAG_CASTS_SHADOWS == LIGHT_FLAG_CASTS_SHADOWS)
						{
							// We are inside the light radius.
							// Define a ray, consisting of origin, direction, and the min-max distance values
							RayDesc ray;
							ray.TMin = rayStartDistance;
							ray.TMax = payload.maxDistance;
							ray.Origin = worldPosition;
							ray.Direction = lightVector;

							TraceRay(
								SceneBVH,
								RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH, //RAY_FLAG_CULL_BACK_FACING_TRIANGLES,
								INSTANCE_MASK_CAST_SHADOW, // Only cast against shadow casting objects.
								0,
								0, // First Hit Shader
								0, // Miss Shader
								ray,
								payload
							);
						}

						if (payload.intensity > 0.0)
						{
							resultMask += shadowMask;

							localDiffuse += (light.color.rgb * lightColor); // TODO: Get real light and color from the light texture.
						}
					}

					resultDiffuse += saturate(localDiffuse); // TODO: Change this to a colour light space
				} 
			}
		}
	}
	
	shadowMask[DispatchRaysIndex().xy] = ConvertShadowmapMaskToVector(resultMask);
	diffuseMask[DispatchRaysIndex().xy] = float4(saturate(resultDiffuse.rgb), 1.0);
}