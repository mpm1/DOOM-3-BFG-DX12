#include "raytracing_global.inc"

// Raytracing output to texture, accessed as UAV
RWTexture2D<float4> gOutput :register(u0);

// Raytracing acceleration structure, accessed as a SRV
RaytracingAccelerationStructure SceneBVH :register(t0);

// Depth buffer used to access the initial location
uniform Texture2D<float4>	depthBuffer : register(t1);

// Constants used to define the camera state
ConstantBuffer<SceneConstants> sceneConstants : register(b0, space0);

bool IsInsideViewport(float2 p, float4 viewport)
{
	return (p.x >= viewport.x && p.x <= viewport.z)
		&& (p.y >= viewport.y && p.y <= viewport.w);

	return true;
}

[shader("raygeneration")]
void RayGen() {
	// Initialize the ray payload
	HitInfo payload;
	payload.maxDistance = 100.0f;
	payload.diffuse = float3(0.0f, 0.0f, 0.0f);

	// Get the ray location on the screen
	float2 lerpValues = (float2)DispatchRaysIndex() / (float2)DispatchRaysDimensions();
	float3 screenLocation = float3(
		lerp(sceneConstants.rpViewport.x, sceneConstants.rpViewport.z, lerpValues.x),
		lerp(sceneConstants.rpViewport.y, sceneConstants.rpViewport.w, lerpValues.y),
		0.0f);

	float3 locationDif = float3(0.0f, 0.0f, 0.0f);

	if (IsInsideViewport(screenLocation.xy, sceneConstants.rpScissor))
	{
		// Get the depth buffer location
		float depth = depthBuffer.Gather(pointSampler, lerpValues.xy).r;

		if(depth <= 1.0f)
		{
			float3 worldPosition = GetWorldPointFromDepth(depth, lerpValues, sceneConstants).xyz;
			float3 eyePosition = sceneConstants.rpGlobalEyePos.xyz;
			float3 lightPosition = eyePosition + float3(0.0f, 10.0f, 10.0f);

			// Define a ray, consisting of origin, direction, and the min-max distance values
			RayDesc ray;
			ray.TMin = 6.0;
			ray.TMax = payload.maxDistance; //max(distance(lightPosition, worldPosition) - ray.TMin, 0);
			ray.Origin = worldPosition;
			ray.Direction = normalize(float3(1.0, 1.0, 1.0)); //normalize(lightPosition - worldPosition);
			//ray.Direction.z = -ray.Direction.z;

			TraceRay(
				SceneBVH,
				RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH, //RAY_FLAG_CULL_BACK_FACING_TRIANGLES,
				0xFF,
				0,
				0, // First Hit Shader
				0, // Miss Shader
				ray,
				payload
			);

			//locationDif = (clamp(worldPosition / 600.0, -1.0, 1.0) + 1.0) * 0.5;
			float dist = clamp(distance(worldPosition, eyePosition) / 10000.0, 0, 1.0);
			payload.diffuse.b = dist * dist; //Mark start here. why is everything on it's side?
			
			//float3 lines = abs(worldPosition % 10.0);
			//const float lineThickness = 0.5;
			//float value = lines.x < lineThickness ? lines.x : lines.y < lineThickness ? lines.y : lines.z < lineThickness ? lines.z : 0;
			//payload.diffuse.r = (1.0 - abs((value / lineThickness) * 2.0 - 1.0)) * dist;
		}
	}
	
	gOutput[DispatchRaysIndex().xy].rgb = payload.diffuse;
	gOutput[DispatchRaysIndex().xy].a = 1.0f;
}