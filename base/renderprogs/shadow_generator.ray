#include "raytracing_global.inc"

// Raytracing output to texture, accessed as UAV
RWTexture2D<float4> gOutput :register(u0);

// Raytracing acceleration structure, accessed as a SRV
RaytracingAccelerationStructure SceneBVH :register(t0);

// Constants used to define the camera state
ConstantBuffer<SceneConstants> sceneConstants : register(b0, space0);

bool IsInsideViewport(float2 p, float4 viewport)
{
	return (p.x >= viewport.x && p.x <= viewport.z)
		&& (p.y >= viewport.y && p.y <= viewport.w);

	return true;
}

[shader("raygeneration")]
void RayGen() {
	// Initialize the ray payload
	HitInfo payload;
	payload.diffuse = float3(0.0f, 0.0f, 0.0f);
	payload.indirect = float3(0.0f, 0.0f, 0.0f);
	payload.specular = float3(0.0f, 0.0f, 0.0f);

	// Get the ray location on the screen
	float2 lerpValues = (float2)DispatchRaysIndex() / (float2)DispatchRaysDimensions();
	float3 screenLocation = float3(
		lerp(sceneConstants.rpViewport.x, sceneConstants.rpViewport.z, lerpValues.x),
		lerp(sceneConstants.rpViewport.y, sceneConstants.rpViewport.w, lerpValues.y),
		0.0f);

	if (IsInsideViewport(screenLocation.xy, sceneConstants.rpScissor))
	{
		// Define a ray, consisting of origin, direction, and the min-max distance values
		RayDesc ray = GenerateCameraRay(DispatchRaysIndex().xy, sceneConstants);
		ray.TMin = 0.01;
		ray.TMax = 100000;

		TraceRay(
			SceneBVH,
			RAY_FLAG_NONE, //RAY_FLAG_CULL_BACK_FACING_TRIANGLES,
			0xFF,
			0,
			0, // First Hit Shader
			0, // Miss Shader
			ray,
			payload
		);
	}
	
	gOutput[DispatchRaysIndex().xy].rgb = payload.diffuse;
	gOutput[DispatchRaysIndex().xy].a = 1.0f;
}